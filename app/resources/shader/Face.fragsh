#version 120

/*
 Copyright (C) 2010-2017 Kristian Duske
 
 This file is part of TrenchBroom.
 
 TrenchBroom is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 TrenchBroom is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with TrenchBroom. If not, see <http://www.gnu.org/licenses/>.
 */

struct PointLight {
    vec3 Intensity;
    vec3 Position;
    float AttenuationConstant;
    float AttenuationLinear;
    float AttenuationQuadratic;
};

const int maxLights = 8;
uniform int NumLights;
uniform PointLight lights[maxLights];
uniform vec3 AmbientLight;
uniform bool EnableLighting;

uniform float Brightness;
uniform float Alpha;
uniform bool EnableMasked;
uniform bool ApplyTexture;
uniform sampler2D Texture;
uniform bool ApplyTinting;
uniform vec4 TintColor;
uniform bool GrayScale;
uniform bool RenderGrid;
uniform float GridSize;
uniform float GridAlpha;
uniform float MajorDivisionSize;
uniform vec3 GridColor;
uniform vec3 CameraPosition;

// shading
uniform bool ShadeFaces;
uniform float ShadeLevel;

// fog parameter
uniform bool ShowFog;
uniform vec4 FogColor;
uniform float FogMaxAmount;
uniform float FogMinDistance;
uniform float FogScale;
uniform float FogBias;
uniform int FogType;

uniform int AutoBrightnessType;
uniform float GridLineWidth;
varying vec4 modelCoordinates;
varying vec3 modelNormal;
varying vec4 faceColor;
varying vec3 viewVector;


float grid(vec3 coords, vec3 normal, float gridSize, float minGridSize, float lineWidthFactor, float majorLineFactor);
vec3 applySoftMapBoundsTint(vec3 inputFragColor, vec3 worldCoords);

void main() {
    if (ApplyTexture)
    gl_FragColor = texture2D(Texture, gl_TexCoord[0].st);
    else
    gl_FragColor = faceColor;

    // Assume alpha masked or opaque.
    // TODO: Make this optional if we gain support for translucent textures
    if (EnableMasked && gl_FragColor.a < 0.5) {
        discard;
    }

    gl_FragColor = vec4(vec3(Brightness * gl_FragColor), gl_FragColor.a);
    gl_FragColor = clamp(gl_FragColor, 0.0, 1.0);
    gl_FragColor.a = Alpha;

    if (GrayScale) {
        float gray = dot(gl_FragColor.rgb, vec3(0.299, 0.587, 0.114));
        gl_FragColor = vec4(gray, gray, gray, gl_FragColor.a);
    }

    if (ApplyTinting) {
        gl_FragColor = vec4((gl_FragColor.rgb + TintColor.rgb * TintColor.a)*0.5f, gl_FragColor.a);
        float brightnessCorrection = 1.0;

        // average color brightness
        if (AutoBrightnessType == 1){
            brightnessCorrection = 0.33 / ((abs(TintColor.r) + abs(TintColor.g) + abs(TintColor.b)) / 3.0);
        }

        // peak color brightness
        if (AutoBrightnessType == 2) {
            brightnessCorrection = 1.0 / max(max(abs(TintColor.r), abs(TintColor.g)), abs(TintColor.b));
        }

        gl_FragColor = clamp(brightnessCorrection * gl_FragColor, 0.0, 1.0);
    }

    if (ShadeFaces) {
        // angular dimming ( can be controlled with dimStrength )
        float dimStrength = clamp(ShadeLevel, 0.0, 1.0);
        float angleDim = dot(normalize(viewVector), normalize(modelNormal)) * dimStrength + (1.0 - dimStrength);

        gl_FragColor.rgb *= angleDim;
    }

    if (ShowFog) {
        float distance = length(viewVector);

        vec3 fogColor = FogColor.rgb;
        float maxFogAmount = FogMaxAmount;
        float fogBias = FogBias;
        float fogScale = FogScale;
        float fogMinDistance = FogMinDistance;

        float fogFactor = max(distance - fogMinDistance, 0.0) * fogScale;

        if (FogType>0) {
            gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, clamp((gl_FragCoord.z / gl_FragCoord.w) * fogScale + fogBias, 0.0, maxFogAmount));
        }
        else {
            gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, clamp(fogFactor + fogBias, 0.0, maxFogAmount));
        }
    }

    if (RenderGrid && GridAlpha > 0.0) {
        vec3 coords = modelCoordinates.xyz;

        // get the maximum distance in world space between this and the neighbouring fragments
        float maxWorldSpaceChange = max(length(dFdx(coords)), length(dFdy(coords)));

        // apply the Nyquist theorem to get the smallest grid size that would make sense to render for this fragment
        float minGridSize = 2.0 * maxWorldSpaceChange;

        float gridValue = grid(coords, modelNormal.xyz, GridSize, minGridSize, GridLineWidth, MajorDivisionSize);
        gl_FragColor.rgb = mix(gl_FragColor.rgb, GridColor, gridValue * GridAlpha);
    }

    if (EnableLighting) {
        for (int i=0; i < NumLights; i++) {
            PointLight light = lights[i];

            // light parts
            vec3 Ia = AmbientLight;
            vec3 Id = vec3(0, 0, 0);
            vec3 Is = vec3(0, 0, 0);

            vec3 N = normalize(modelNormal.xyz);
            vec3 L = normalize(light.Position - modelCoordinates.xyz);
            vec3 R = normalize(reflect(-L, N));
            vec3 V = normalize(CameraPosition - modelCoordinates.xyz);

            float Distance = length(light.Position - modelCoordinates.xyz);
            float linearAttenuation = light.AttenuationLinear * Distance;
            float quadraticAttenuation = light.AttenuationLinear * Distance* Distance;
            float Attenuation = 1.0f / (light.AttenuationConstant + linearAttenuation + quadraticAttenuation);

            // diffuse Intensity
            Id = Id + light.Intensity * max(0, dot(N, L)) * Attenuation;
            // specular intensity
            Is = Is + light.Intensity * max(0, pow(max(0, dot(R, V)), max(1, 1))) * Attenuation;
            // final fragment color
            vec3 color = (Ia + Id) + Is;

            gl_FragColor.rgb = gl_FragColor.rgb * clamp(color, 0, 1);
        }
    }

    gl_FragColor.rgb = applySoftMapBoundsTint(gl_FragColor.rgb, modelCoordinates.xyz);
}
