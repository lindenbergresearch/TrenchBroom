#version 120

/*
 Copyright (C) 2010-2017 Kristian Duske
 
 This file is part of TrenchBroom.
 
 TrenchBroom is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 TrenchBroom is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with TrenchBroom. If not, see <http://www.gnu.org/licenses/>.
 */

struct PointLight {
	vec3 Intensity;
	vec3 Position;
	float AttenuationConstant;
	float AttenuationLinear;
	float AttenuationQuadratic;
};

uniform vec4 Color;
uniform vec3 CameraPosition;

const int maxLights = 64;
uniform int NumLights;
uniform PointLight lights[maxLights];
uniform vec3 AmbientLight;
uniform bool EnableLighting;

varying vec4 modelCoordinates;
varying vec3 modelNormal;
varying vec4 faceColor;
varying vec3 viewVector;
varying vec3 lightColor;

void main(void) {
	gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;
	gl_TexCoord[0] = gl_MultiTexCoord0;
	modelCoordinates = gl_Vertex;
	modelNormal = gl_Normal;
	faceColor = Color;
	viewVector = CameraPosition - gl_Vertex.xyz;

	vec3 N = normalize(modelNormal.xyz);
	vec3 V = normalize(CameraPosition - modelCoordinates.xyz);

	if (EnableLighting) {
		vec3 _lightColor = vec3(0, 0, 0);;

		for (int i=0; i < NumLights; i++) {
			PointLight light = lights[i];

			float Distance = length(light.Position - modelCoordinates.xyz);

			light.AttenuationConstant = max(light.AttenuationConstant, 1.f);
			light.AttenuationQuadratic = max(light.AttenuationConstant, 1.f);
			light.AttenuationLinear = max(light.AttenuationConstant, 1.f);

			// light parts
			vec3 Ia = AmbientLight;
			vec3 Id = vec3(0, 0, 0);
			vec3 Is = vec3(0, 0, 0);

			vec3 L = normalize(light.Position - modelCoordinates.xyz);
			vec3 R = normalize(reflect(-L, N));

			float linearAttenuation = light.AttenuationLinear * Distance;
			float quadraticAttenuation = light.AttenuationQuadratic * Distance * Distance;
			float Attenuation = 1.0f / (light.AttenuationConstant + linearAttenuation + quadraticAttenuation);

			// diffuse Intensity
			Id = light.Intensity * max(0, dot(N, L)) * Attenuation;

			// specular intensity
			light.Intensity * max(0, max(0, dot(R, V))) * Attenuation;

			// final fragment color
			vec3 color = clamp(Ia + Id + Is, 0.0f, 2.25f);

			//lightColor = clamp((lightColor + color)*0.5, 0.0f, 1.2f);
			_lightColor += color;
		}

		lightColor.rgb = clamp(_lightColor, 0.0f, 2.25f);
//
//		float gamma = 1.2;
//		lightColor.rgb = pow(lightColor.rgb, vec3(1.0/gamma));
	}

}
